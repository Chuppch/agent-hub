## ExecutionHistoryManager 对象设计

### 一、对象基本信息

**对象名称：** `ExecutionHistoryManager`

**核心职责：**
- 管理执行历史记录（详细层 + 摘要层）
- 实现滑动窗口机制，控制历史记录长度
- 自动压缩历史记录，生成摘要
- 根据需求提供不同粒度的历史信息

---

### 二、字段设计

#### 字段1：recentDetailedHistory（最近详细记录）

- **名称：** `recentDetailedHistory`
- **作用：** 存储最近 N 步的完整执行记录（滑动窗口的详细层）
- **数据格式：** `List<StepRecord>` 或 `Deque<StepRecord>`
  - 推荐使用 `Deque`（双端队列），便于从头部移除旧记录
- **说明：**
  - 每步执行后追加一条完整记录
  - 当超过窗口大小时，从头部移除最旧的记录
  - 保留最近 5-10 步的完整信息

#### 字段2：summaryHistory（摘要历史）

- **名称：** `summaryHistory`
- **作用：** 存储更早步骤的摘要信息（压缩后的历史）
- **数据格式：** `String` 或 `List<SummaryRecord>`
  - 如果使用 `String`：所有摘要拼接成一个字符串
  - 如果使用 `List<SummaryRecord>`：每个摘要是一个独立对象，更灵活
- **说明：**
  - 当详细记录超过窗口大小时，将最旧的记录压缩为摘要
  - 摘要包含关键信息：任务状态、完成度、关键结果等
  - 可以累积多个摘要

#### 字段3：windowSize（窗口大小）

- **名称：** `windowSize`
- **作用：** 控制详细层保留多少步的完整记录
- **数据格式：** `int`
- **默认值：** 建议 5-10
- **说明：**
  - 可配置参数
  - 根据任务复杂度调整
  - 窗口越大，保留的详细信息越多，但 token 消耗也越大

#### 字段4：compressionBatchSize（压缩批次大小）

- **名称：** `compressionBatchSize`
- **作用：** 每次压缩时处理多少步的记录
- **数据格式：** `int`
- **默认值：** 建议 3-5
- **说明：**
  - 当详细记录超过窗口大小时，每次压缩处理 N 步
  - 避免频繁压缩，提高效率
  - 可以批量处理，减少压缩次数

#### 字段5：totalSteps（总步数）

- **名称：** `totalSteps`
- **作用：** 记录总执行步数
- **数据格式：** `int`
- **说明：**
  - 每步执行后递增
  - 用于统计和日志
  - 用于判断是否需要压缩

#### 字段6：compressionStrategy（压缩策略）

- **名称：** `compressionStrategy`
- **作用：** 定义如何压缩历史记录（简单提取 vs AI 摘要）
- **数据格式：** `enum CompressionStrategy`
  - `SIMPLE_EXTRACT`：简单提取关键字段
  - `AI_SUMMARY`：调用 AI 模型生成摘要
  - `STRUCTURED_COMPRESS`：结构化压缩（JSON/表格）
- **说明：**
  - 可配置的压缩策略
  - 不同策略有不同的成本和效果
  - 可以根据场景选择

#### 字段7：maxSummaryLength（最大摘要长度）

- **名称：** `maxSummaryLength`
- **作用：** 控制摘要层的最大长度（避免摘要也无限增长）
- **数据格式：** `int`
- **默认值：** 建议 5000-10000 字符
- **说明：**
  - 当摘要层超过此长度时，可以进一步压缩或移除最旧的摘要
  - 防止摘要层也无限增长

---

### 三、内部数据结构设计

#### 数据结构1：StepRecord（步骤记录）

- **名称：** `StepRecord`
- **作用：** 表示单步执行的完整记录
- **字段：**
  - `stepNumber`（int）：步数
  - `analysisResult`（String）：分析阶段的结果
  - `executionResult`（String）：执行阶段的结果
  - `supervisionResult`（String）：监督阶段的结果
  - `timestamp`（long）：执行时间戳
  - `stepSummary`（String）：格式化后的完整记录

#### 数据结构2：SummaryRecord（摘要记录）

- **名称：** `SummaryRecord`
- **作用：** 表示压缩后的摘要信息
- **字段：**
  - `startStep`（int）：起始步数
  - `endStep`（int）：结束步数
  - `summary`（String）：摘要内容
  - `keyPoints`（List<String>）：关键点列表
  - `timestamp`（long）：生成时间戳

---

### 四、核心方法设计

#### 方法1：appendStep（追加新步骤）

- **方法名：** `appendStep(int stepNumber, String analysisResult, String executionResult, String supervisionResult)`
- **作用：** 将新步骤的完整记录追加到详细层
- **逻辑：**
  1. 创建 `StepRecord` 对象
  2. 追加到 `recentDetailedHistory`
  3. 递增 `totalSteps`
  4. 检查是否需要压缩（如果 `recentDetailedHistory.size() > windowSize`）
  5. 如果需要，调用 `compressHistory()` 方法
- **返回值：** `void`

#### 方法2：compressHistory（压缩历史）

- **方法名：** `compressHistory()`
- **作用：** 将详细层中最旧的记录进行摘要，移到摘要层
- **逻辑：**
  1. 从 `recentDetailedHistory` 头部取出最旧的 `compressionBatchSize` 条记录
  2. 根据 `compressionStrategy` 进行压缩：
     - `SIMPLE_EXTRACT`：提取关键字段（任务状态、完成度、关键结果）
     - `AI_SUMMARY`：调用 AI 模型生成摘要（可选，增加成本）
     - `STRUCTURED_COMPRESS`：使用结构化格式压缩
  3. 将摘要追加到 `summaryHistory`
  4. 从 `recentDetailedHistory` 中移除这 N 条记录
  5. 检查 `summaryHistory` 是否超过 `maxSummaryLength`，如果超过则进一步压缩
- **返回值：** `void`

- 

#### 方法名3： getHistory()

- **方法名：** `getHistory()`

- **作用：** 返回完整的执行历史（摘要 + 详细记录）

- 逻辑：

  - 格式化 summaryHistory（如果有）

  - 格式化 recentDetailedHistory（最近 N 步）

  - 拼接：summaryHistory + "\n\n" + recentDetailedHistory

  - 返回格式化后的字符串

- **返回值：** String

- **用途：** 用于分析器提示词和最终总结报告

#### 方法4：shouldCompress（判断是否需要压缩）

- **方法名：** `shouldCompress()`
- **作用：** 判断是否需要压缩历史记录
- **逻辑：**
  1. 检查 `recentDetailedHistory.size() > windowSize`
  2. 返回布尔值
- **返回值：** `boolean`
- **用途：** 内部方法，用于判断压缩时机

#### 方法5：extractKeyInfo（提取关键信息）

- **方法名：** `extractKeyInfo(StepRecord record)`
- **作用：** 从步骤记录中提取关键信息（用于简单压缩策略）
- **逻辑：**
  1. 从 `analysisResult` 中提取：任务状态、完成度评估
  2. 从 `executionResult` 中提取：执行目标、关键结果
  3. 从 `supervisionResult` 中提取：质量评分、是否通过
  4. 返回关键信息字符串
- **返回值：** `String`
- **用途：** 内部方法，用于简单压缩策略

---



